import sys^M
import json^M
import time^M
#This code has been written in a single file so that^M
#Further a structured programming approch is taken over^M
#OO on account of simplicity and ease of understanding^M
#and given the complexcity of this code^M
^M
'''^M
This code is a Turing machine simulator. On a high level it reads ^M
a file in this format and then executes the same.^M
^M
The motivation of this code is that existing Turing machine simulators ^M
make a number of assumptions about the TUring machine such as naming convention^M
of states, not having multiple halt states, assuming the blank charecter on tape,^M
assuming the read head can move only left or right and cant stay stationary, input ^M
alphabet and tape alphabet are the same etc.^M
^M
This application is a command line turing machine that takes the input file as an argument^M
and then execturs the same.^M
^M
The general structure of the file is as follows:^M
1. Read the file into list of lines^M
2. Parse the list of lines and remove any comments (starting with #) or blanks^M
3. Convert the residual file into a dictionary for turing machine of the structure^M
^M
Name = Add Two Uniary Numbers^M
Description = Adds Two uniary Numbers^M
^M
#The initial input alphabet^M
Tape_Alphabet = 0,c,#,x,d,?^M
^M
#Blank Symbol of tape^M
Blank_Symbol = #^M
^M
#Initial input String^M
Input = 00c00^M
^M
#Initial head position on input string, count starts with 0^M
Position=0^M
^M
#Maps to any symbol^M
Any_Symbol_Wild_Card =?^M
^M
#Set of States^M
States = Q0,Q1,Q2,Q3,Q4,Q5^M
^M
#Initial State^M
Initial_State = Q0^M
^M
#Set of accepted final states after which machine halts^M
Final_States = Q5^M
^M
Shift = Left,Right,No_Shift^M
^M
Left_Shift_Symbol = Left^M
Right_Shift_Symbol = Right^M
No_Shift_Symbol = No_Shift^M
^M
#State Transition Table^M
S.No,   Current_State,	Input_Alphabet,		Output_Alphabet,		New_State,	Left_Right_No_Sift^M
1,Q0,0,x,Q1,Right^M
2,Q1,0,0,Q1,Right^M
3,Q1,c,c,Q2,Right^M
4,Q2,0,0,Q2,Right^M
5,Q2,#,0,Q3,Left^M
6,Q3,0,0,Q3,Left^M
7,Q3,c,c,Q4,Left^M
8,Q4,0,0,Q4,Left^M
9,Q4,x,x,Q0,Right^M
10,Q0,c,#,Q5,Right^M
^M
4. Validate the Turing machine for static errors such as undefined states, alphabets etc^M
5. Execute the Turing machine^M
'''^M
^M
#In an ideal world these would have gone into a mapping file ^M
#or a constants or a config file. However in interest of^M
#keeping code in one file we are making them constants^M
^M
'''^M
The key to split key value pairs in line^M
'''^M
LINE_SPLIT_CHAR = '='^M
^M
'''^M
The number of entries in key value pair^M
'''^M
LINE_SPLIT_PARTS = 2^M
^M
'''^M
Key will be the first part in the split^M
'''^M
LINE_SPLIT_PART_KEY = 0^M
^M
'''^M
Value will be the second part in the split^M
'''^M
LINE_SPLIT_PART_VALUE = 1^M
^M
'''^M
The name of the turing machine^M
'''^M
TURING_MACHINE_NAME_KEY = 'Name'^M
^M
'''^M
Description of the turing machine^M
'''^M
TURING_MACHINE_DESCRIPTION = 'Description'^M
^M
'''^M
The blank symbol of the tape^M
'''^M
BLANK_SYMBOL = 'Blank_Symbol'^M
^M
'''^M
The initial input of the tape^M
'''^M
INPUT = "Input"^M
^M
'''^M
The position of the head on the tape^M
'''^M
POSITION = "Position"^M
^M
'''^M
The initial state of the turing machine^M
'''^M
INITIAL_STATE = "Initial_State"^M
^M
ANY_SYMBOL_WILD_CARD = "Any_Symbol_Wild_Card"^M
^M
'''^M
The symbol that is used to represent the left shift in the turing machine^M
'''^M
LEFT_SHIFT_SYMBOL ="Left_Shift_Symbol"^M
^M
'''^M
The symbol that is used to represent the right shift in the turing machine^M
'''^M
RIGHT_SHIFT_SYMBOL = "Right_Shift_Symbol"^M
^M
'''^M
The symbol that is used to represent the no shift in the turing machine^M
'''^M
NO_SHIFT_SYMBOL = "No_Shift_Symbol"^M
^M
'''^M
The  set of keys that will be simple key value pairs in the turing machine^M
'''^M
turing_machine_simple_key_names = [TURING_MACHINE_NAME_KEY, TURING_MACHINE_DESCRIPTION,^M
                                   BLANK_SYMBOL,BLANK_SYMBOL,INPUT,INITIAL_STATE,^M
                                   POSITION,ANY_SYMBOL_WILD_CARD, LEFT_SHIFT_SYMBOL,^M
                                   RIGHT_SHIFT_SYMBOL, NO_SHIFT_SYMBOL]^M
^M
#The undergiven keys will be arrays in the file^M
^M
'''^M
The set of alphabet in the tape, blank symbol and the initial input^M
are expected to be part of this alphabet and shall be validated^M
'''^M
TAPE_ALPHABET = "Tape_Alphabet"^M
^M
'''^M
The complete set of states of the turing machine. The initial state, ^M
final state and the states in the state transition table are expected^M
to be part of this set of states^M
'''^M
STATES = "States"^M
^M
'''^M
The array of final states, if any of these states are encountered the turing^M
mahine will halt^M
'''^M
FINAL_STATES = "Final_States"^M
^M
'''^M
This contains the keys that will be assumed to be arrays in^M
the input file for the turing machine.^M
'''^M
turing_machine_array_key_names = [TAPE_ALPHABET,STATES,FINAL_STATES]^M
^M
'''^M
The seperator of the array^M
'''^M
ARRAY_SEPERATOR = ","^M
^M
#These are the column headers for the state transition table^M
'''^M
The Serial number of the state transition table^M
'''^M
STATE_TABLE_HEADER_ENTRY_STARTS_WITH = "S.No"^M
^M
'''^M
The seperator for state transtion table columns^M
'''^M
STATE_TRANSITION_ENTRY_SEPERATOR = ","^M
^M
'''^M
The dictionary key for the state transition table in the turing machine^M
'''^M
STATE_TRANSITION_TABLE = "State_Transition_Table"^M
^M
'''^M
The column number for Serial number in the state transition table^M
'''^M
S_NO_COLUMN = 0^M
^M
'''^M
The column number for current state in the state transition table^M
'''^M
CURRENT_STATE_COLUMN = 1^M
^M
'''^M
The column number for current alphabet in the state transition table^M
'''^M
CURRENT_ALPHABET_COLUMN =2^M
^M
'''^M
The column number for new alphabet in the state transition table^M
'''^M
NEW_ALPHABET_COLUMN=3^M
^M
'''^M
The column number for new state in the state transition table^M
'''^M
NEW_STATE_COLUMN= 4^M
^M
'''^M
The column number for shift direction in the state transition table^M
'''^M
SHIFT_COLUMN = 5^M
^M
'''^M
The key name for new alphabet^M
'''^M
NEW_ALPHABET = "New_Alphabet"^M
^M
'''^M
The key name for new state^M
'''^M
NEW_STATE = "New_State"^M
^M
'''^M
The key name for Shift direction^M
'''^M
SHIFT = "Shift"^M
^M
'''^M
The current state of the turing machine^M
'''^M
CURRENT_STATE = "Current_State"^M
^M
'''^M
The tape of turing machine^M
'''^M
TAPE = "Tape"^M
^M
'''^M
Current position on the tape^M
'''^M
CURRENT_POSITION = "Current_Position"^M
^M
'''^M
Color to be shown for current tape head (Red)^M
'''^M
COLOR_FOR_CURRENT_TAPE_HEAD = "\033[31m"^M
^M
'''^M
Color to reset the color of the terminal^M
'''^M
COLOR_TO_RESET = "\033[0m"^M
^M
'''^M
Character to print when prnting tape head^M
'''^M
WHITE_SPACE = " "^M
^M
'''^M
Chaaracter to print when prnting tape head^M
'''^M
TAPE_HEAD_MARKET = "^"^M
^M
'''^M
Number of columns expected in each row of state transition table^M
These are S.No, Current State, Current Alphabet, New Alphabet, New State, Shift^M
'''^M
NUMBER_OF_COLUMNS_IN_STATE_TRANSITION_TABLE = 6^M
^M
^M
'''^M
The key to be used for execution counter^M
'''^M
EXECUTION_COUNTER = "Execution_Counter"^M
^M
'''^M
Initial value of the execution counter^M
'''^M
EXECUTION_COUNTER_INITIAL_VALUE = 0^M
^M
'''^M
Increment value for the execution counter^M
'''^M
EXECUTION_COUNTER_INCREMENT = 1^M
^M
^M
def read_file_into_list(file_path:str)->list:^M
    """^M
    Reads the contents of a file and returns a list of its lines.^M
    The comments in the file are expected to begin with #^M
    This method will not check the structure of the file. ^M
    As the file to be read is a Turing machine file it is expected to ^M
    be small in size and hence reading the entire file into memory is acceptable.^M
^M
    Args:^M
        file_path (str): The path to the file to be read.^M
^M
    Returns:^M
        list: A list containing each line from the file as a string.^M
    """^M
    #Open the file in read mode and read all lines into a list^M
    with open(file_path, 'r') as f:^M
        #The with ensures the file is properly closed after reading^M
        #Hence no need to explicitly close the file or exception handeling^M
        return f.readlines()^M
^M
def print_file(file:list):^M
    """^M
    Prints each line from the provided list of file lines.^M
^M
    Args:^M
        file (list): List of strings, each representing a line from a file.^M
^M
    Returns:^M
        None^M
    """^M
    for line in file:^M
        print(line)^M
    ^M
def remove_comments_and_empty_lines_from_list(lst:list[str])->list[str]:^M
    """^M
    Removes comment lines (starting with '#') and empty lines from a list of strings.^M
^M
    Args:^M
        lst (list): List of strings.^M
^M
    Returns:^M
        list: A new list containing only non-comment, non-empty lines, ^M
        stripped of leading/trailing whitespace.^M
    """^M
    new_list = []^M
    for line in lst:^M
        # Check if the line does not start with '#' and is not empty after stripping whitespace^M
        if not line.startswith("#") and line.strip():^M
            # Add the cleaned line to the new list^M
            new_list.append(line.strip())^M
    return new_list^M
^M
^M
def add_turing_machine_element_to_dictionary(turing_machine_dictionary:dict, key:str, value:str):^M
    #In this code we do all the magic number and string code.^M
    #In an ideal world this mapping should be done in a config file^M
    #However as we want to keep things in one file we will use constants^M
    if(key in turing_machine_simple_key_names):^M
        #If the key is a simple key then we add it to dictionay as a key value pair^M
        #Things like inital state, name ^M
        turing_machine_dictionary[key] = value^M
    elif(key in turing_machine_array_key_names):^M
        turing_machine_dictionary[key] = value.split(ARRAY_SEPERATOR)^M
^M
^M
def add_or_get_state_transition_table_node(turing_machine_dictionary:dict)->dict:^M
    """^M
    Retrieves the state transition table node from the given Turing machine dictionary.^M
    If the state transition table does not exist, it initializes an empty dictionary for it.^M
^M
    Args:^M
        turing_machine_dictionary (dict): The dictionary representing the Turing machine.^M
^M
    Returns:^M
        dict: The state transition table node from the Turing machine dictionary.^M
^M
    Comments:^M
        - The state transition table is typically used to define the rules for state transitions in a Turing machine.^M
        - The function ensures that the state transition table exists in the dictionary before returning it.^M
    """^M
    if(turing_machine_dictionary.get(STATE_TRANSITION_TABLE) is None):^M
        #If the state transition table does not exist then we initialize it^M
        turing_machine_dictionary[STATE_TRANSITION_TABLE] = {}^M
        #And then return it^M
    return turing_machine_dictionary[STATE_TRANSITION_TABLE]^M
^M
^M
def add_or_get_current_node(state_transition_table:dict,current_state:str)->dict:^M
    """^M
    Retrieves the transition dictionary for the given current state from the state transition table.^M
    If the current state does not exist in the table, initializes it with an empty dictionary.^M
^M
    Args:^M
        state_transition_table (dict): The dictionary representing the state transition table.^M
        current_state (str): The state whose transition dictionary is to be retrieved or initialized.^M
^M
    Returns:^M
        dict: The transition dictionary associated with the current state.^M
    """^M
    #Check if the node for current state exists^M
    if(state_transition_table.get(current_state) is None):^M
        #if not then create it^M
        state_transition_table[current_state] = {}^M
    return state_transition_table[current_state]^M
^M
^M
def add_turing_machine_state_transition_entry_to_dictionary(turing_machine_dictionary:dict^M
                                                            , state_transition_entry:str):^M
    """^M
    Adds a state transition entry to the Turing machine's transition dictionary.^M
    This function parses a state transition entry string, extracts its components,^M
    and inserts the transition into the appropriate location in the Turing machine's^M
    state transition table. If the entry is a header or already exists, it will be ignored^M
    or raise an exception, respectively.^M
    Args:^M
        turing_machine_dictionary (dict): The dictionary representing the Turing machine's state transitions.^M
        state_transition_entry (str): The string containing the state transition entry to be added.^M
    Raises:^M
        Exception: If a transition for the given state and alphabet already exists.^M
    Returns:^M
        None^M
    """^M
    ^M
    #Check if the entry is a header, if so return^M
    if(state_transition_entry.startswith(STATE_TABLE_HEADER_ENTRY_STARTS_WITH)):^M
        return^M
    ^M
    #split the transtion entry into columns after removing spaces and tabs using^M
    #, as a seperator^M
    parts = state_transition_entry.strip().replace(" ","").replace("\t","").split(^M
        STATE_TRANSITION_ENTRY_SEPERATOR)^M
    ^M
    #Check the number of entries are correct in the table^M
    if(len(parts) != NUMBER_OF_COLUMNS_IN_STATE_TRANSITION_TABLE):^M
        raise Exception("State transition entry does not have "^M
                        + str(NUMBER_OF_COLUMNS_IN_STATE_TRANSITION_TABLE)^M
                        + " elements for the state transition entry: " + state_transition_entry)^M
                    ^M
    ^M
    #Check if the state state transtion key exists in the json, if not create^M
    state_transition_table = add_or_get_state_transition_table_node(turing_machine_dictionary)^M
    ^M
    #Check if the entry in the state transition exists for the current node exists^M
    #if not then create one^M
    current_state_node = add_or_get_current_node(state_transition_table,parts[CURRENT_STATE_COLUMN])^M
    #Check if the Current node has an entry for the alphabet^M
    #if not make an entry^M
    if(current_state_node.get(parts[CURRENT_ALPHABET_COLUMN])) is None:^M
        current_state_node[parts[CURRENT_ALPHABET_COLUMN]] = {^M
            NEW_ALPHABET:parts[NEW_ALPHABET_COLUMN],^M
            NEW_STATE:parts[NEW_STATE_COLUMN],^M
            SHIFT:parts[SHIFT_COLUMN]^M
        }^M
        #else raise an error because a given node and alphabet^M
        #can not have two entries^M
    else:^M
        raise Exception("State transition entry already exists for State: "^M
                        + parts[CURRENT_STATE_COLUMN] + " and Alphabet: " ^M
                        + parts[CURRENT_ALPHABET_COLUMN] )^M
^M
^M
def convert_list_into_dictionary(lst:list[str])->dict:^M
    """^M
    Converts the file read into the list into a dictionary that represents the Turing machine.^M
    The code parses through each line in file. ^M
    If the line is a seperator then it can be a simple argument or a key value pair^M
    If the line is not a key value pair it is assumed to be a state transition line^M
    The apprpopriate mapping function is called to handle the line^M
    Args:^M
       lst (list[str]): The clean lines read from the file^M
    Returns:^M
        dict: The Turing machine dictionary represntation^M
    """^M
    ^M
    #initialize the turing machine dictionary to blank^M
    turing_machine_dictionary = {}^M
    #For each line in the list^M
    for line in lst:^M
        # split the line into parts using the '=' character as the delimiter^M
        parts = line.split(LINE_SPLIT_CHAR)^M
        # check if the line has exactly two parts^M
        if len(parts) == LINE_SPLIT_PARTS:^M
            # assign the first part to the key variable^M
            key = parts[LINE_SPLIT_PART_KEY].strip()  ^M
            # assign the second part to the value variable  ^M
            value = parts[LINE_SPLIT_PART_VALUE].strip()^M
            #now based on key we will get the structured value^M
            add_turing_machine_element_to_dictionary(turing_machine_dictionary, key, value)^M
        else:^M
            #This will be the case for the states^M
            add_turing_machine_state_transition_entry_to_dictionary(turing_machine_dictionary,line)^M
            ^M
    return turing_machine_dictionary^M
^M
^M
def is_symbol_in_alphabet(alphabet:list[str],symbol:str)->bool:^M
    """^M
    Checks if the  symbol is in the alphabet^M
    Args:^M
        alphabet (str): The alphabet^M
        symbol (str): The blank symbol^M
    Returns:^M
        bool: True if the  symbol is in the alphabet, False otherwise^M
    """^M
    return symbol in alphabet^M
^M
^M
def input_in_alphabet(alphabet:list[str],input:str):^M
    """^M
    Checks if the input is in the alphabet^M
    Args:^M
        alphabet (str): The alphabet^M
        input (str): The input^M
    Returns:^M
        tuple(bool,str): A tuple containing a boolean indicating if the input is in the ^M
        alphabet and the character that is not in the alphabet^M
    """^M
    input_in_alphabet = True^M
    char = None^M
    for input_char in input:^M
        #Check each input charecter in string is in the alphabet^M
        #If not raise error with details of which charecter is not in the alphabet^M
        if(input_char not in alphabet):^M
            input_in_alphabet = False^M
            char = input_char^M
            break^M
    ^M
    return (input_in_alphabet,char)^M
^M
^M
def is_given_state_in_states(states:list[str],initial_state:str):^M
    """^M
    Checks if the  state is in the states^M
    Args:^M
        states (str): The states^M
        initial_state (str): The initial state^M
    Returns:^M
        bool: True if the initial state is in the states, False otherwise^M
    """^M
    return initial_state in states^M
^M
^M
def is_state_list_in_states(states:list[str],states_to_check:str):^M
    """^M
    Checks if the list of states is in the states^M
    Args:^M
        states (str): The states^M
        states_to_check (str): The  states to be checked^M
    Returns:^M
        tuple(bool,str): A tuple containing a boolean indicating if the state(s) is in the ^M
        states  and the state that is not in the states^M
    """^M
    ^M
    final_states_in_states = True^M
    state = None^M
    for current_state in states_to_check:^M
        #Check each state is in the master list if not return details^M
        #which state is not in the states^M
        if(current_state not in states):^M
            final_states_in_states = False^M
            state = current_state^M
            break^M
    ^M
    return (final_states_in_states,state)^M
^M
^M
def is_valid_state_transition_table(turing_machine_dictionary:dict):^M
    """^M
    Validates the state transition table of a Turing machine.^M
    This function checks whether the state transition table provided in the^M
    `turing_machine_dictionary` is valid according to the following criteria:^M
        - All states referenced in the transition table exist in the set of states.^M
        - All tape symbols referenced in the transition table exist in the tape alphabet.^M
        - All new symbols written during transitions exist in the tape alphabet.^M
        - All new states referenced during transitions exist in the set of states.^M
        - All shift directions used in transitions are valid (left, right, or no shift).^M
    Args:^M
        turing_machine_dictionary (dict): A dictionary containing the Turing machine^M
            specification. It must include keys for states, tape alphabet, state^M
            transition table, and shift symbols.^M
    Returns:^M
        tuple:^M
            - bool: True if the state transition table is valid, False otherwise.^M
            - str or None: If invalid, a message describing the error; otherwise, None.^M
    """^M
    ^M
    state_transition_table = turing_machine_dictionary[STATE_TRANSITION_TABLE]^M
    for current_state in state_transition_table.keys():^M
        #Check if the current state is in states^M
        if(is_given_state_in_states(turing_machine_dictionary[STATES],current_state) == False):^M
            return (False,current_state+" not in " + str(turing_machine_dictionary[STATES]))^M
^M
        #Find the transition table for this state^M
        partial_state_transition_table = state_transition_table[current_state]^M
        for current_alphabet in partial_state_transition_table.keys():^M
            #Check if the current alphabet is in the alphabet^M
            if(is_symbol_in_alphabet(turing_machine_dictionary[TAPE_ALPHABET],current_alphabet) == False):^M
                return (False,current_alphabet+" not in " + str(turing_machine_dictionary[TAPE_ALPHABET])^M
                                                                +"for state "+current_state)^M
            #Find the values for new transtion^M
            current_state_alphabet_transtion = partial_state_transition_table[current_alphabet]^M
            ^M
            new_alphabet = current_state_alphabet_transtion[NEW_ALPHABET]^M
            new_state = current_state_alphabet_transtion[NEW_STATE]^M
            shift_direction = current_state_alphabet_transtion[SHIFT]^M
            ^M
            #Check new alphabet in turing machine^M
            if(is_symbol_in_alphabet(turing_machine_dictionary[TAPE_ALPHABET],new_alphabet) == False):^M
                return (False,new_alphabet+" not in " + str(turing_machine_dictionary[TAPE_ALPHABET])^M
                                                            +"for state "+current_state^M
                                                            +" and alphabet "+current_alphabet)^M
            #if the new state is in states^M
            if(is_given_state_in_states(turing_machine_dictionary[STATES],new_state) == False):^M
                return (False,new_state+" not in " + str(turing_machine_dictionary[STATES])^M
                                                            +"for state "+current_state^M
                                                            +" and alphabet "+current_alphabet)^M
            #Check shift direction^M
            shift_array = [^M
                turing_machine_dictionary[LEFT_SHIFT_SYMBOL],^M
                turing_machine_dictionary[RIGHT_SHIFT_SYMBOL],^M
                turing_machine_dictionary[NO_SHIFT_SYMBOL]^M
            ]^M
            if(shift_direction not in shift_array):^M
                return (False,shift_direction+" not in " + str(shift_array)^M
                                                            +"for state "+current_state^M
                                                            +" and alphabet "+current_alphabet)     ^M
            ^M
    return (True,None)^M
^M
^M
def validate_turing_machine(turing_machine_dictionary:dict):^M
    """^M
    Validates the structure and contents of a Turing machine definition provided as a dictionary.^M
    The function performs the following checks:^M
    1. Ensures the blank symbol is present in the tape alphabet.^M
    2. Verifies that all input symbols are included in the tape alphabet.^M
    3. Checks that the initial state is listed among the defined states.^M
    4. Validates that all final states are included in the set of states.^M
    5. Checks the correctness of the transition table, including states, ^M
    input/output alphabet, next state, and direction.^M
    Parameters:^M
        turing_machine_dictionary (dict): ^M
            A dictionary containing the Turing machine specification. Expected keys include:^M
            - TAPE_ALPHABET: List of symbols allowed on the tape.^M
            - BLANK_SYMBOL: The symbol representing a blank cell on the tape.^M
            - INPUT: The input string or list of symbols to be processed.^M
            - STATES: List of all possible states.^M
            - INITIAL_STATE: The starting state of the machine.^M
            - State Transition graph^M
    Raises:^M
        TypeError: If any of the validation checks fail, with a descriptive error message.^M
    """^M
    #check blank symbol is in the alphabet^M
    if(is_symbol_in_alphabet(turing_machine_dictionary[TAPE_ALPHABET]^M
                                   ,turing_machine_dictionary[BLANK_SYMBOL]) == False):^M
        raise TypeError("Blank symbol is not in the alphabet")^M
    ^M
    #check if any symbol in the input is not in the alphabet^M
    if(is_symbol_in_alphabet(turing_machine_dictionary[TAPE_ALPHABET]^M
                                ,turing_machine_dictionary[ANY_SYMBOL_WILD_CARD]) == False):^M
        raise TypeError("Any symbol is not in the alphabet")^M
    ^M
    #check input is in the alphabet^M
    input_in_alphabet_status = input_in_alphabet(turing_machine_dictionary[TAPE_ALPHABET]^M
                                          ,turing_machine_dictionary[INPUT])^M
    if(input_in_alphabet_status[0] == False):^M
        raise TypeError("Input "+input_in_alphabet_status[1]+" is not in the alphabet "^M
                        +str(turing_machine_dictionary[TAPE_ALPHABET]))^M
    ^M
    #check initial state is in States^M
    if(is_given_state_in_states(turing_machine_dictionary[STATES],^M
                                  turing_machine_dictionary[INITIAL_STATE]) == False):^M
        raise TypeError("Initial state " + turing_machine_dictionary[INITIAL_STATE]^M
                        +" is not in the states "+str((turing_machine_dictionary[STATES])))^M
        ^M
    #Check Final States are in states^M
    final_states_in_states_status = is_state_list_in_states(turing_machine_dictionary[STATES],^M
                                                             turing_machine_dictionary[FINAL_STATES])^M
    ^M
    if(final_states_in_states_status[0] == False):^M
        raise TypeError("Final state "+final_states_in_states_status[1]+" is not in the states "^M
                        +str(turing_machine_dictionary[STATES]))^M
        ^M
    #Check tranition table states, input alphabet, output alphabet, next state, and direction^M
    #are correct^M
    state_transition_validation_status = is_valid_state_transition_table(turing_machine_dictionary)^M
    if(state_transition_validation_status[0] == False):^M
        raise TypeError("State transition table is not valid. "+state_transition_validation_status[1])^M
^M
^M
def execute_to_next_state(turing_machine_dictionary:dict):^M
    """^M
    Executes a single transition of the Turing machine, updating its state, tape, and head position.^M
    Args:^M
        turing_machine_dictionary (dict): ^M
            A dictionary representing the current configuration of the Turing machine. ^M
            Expected keys include:^M
                - CURRENT_STATE: The current state of the machine.^M
                - TAPE: The tape as a string.^M
                - CURRENT_POSITION: The current head position (as a stringified integer).^M
                - STATE_TRANSITION_TABLE: The state transition table (dict).^M
                - BLANK_SYMBOL: The symbol representing a blank cell on the tape.^M
    Raises:^M
        Exception: If the current state or current alphabet is not found in the state transition table.^M
    Side Effects:^M
        - Updates the turing_machine_dictionary in-place:^M
            - Sets the new state.^M
            - Writes the new alphabet to the tape at the current position.^M
            - Moves the head left, right, or keeps it in place.^M
            - Expands the tape with blank symbols if the head moves beyond the tape boundaries.^M
    """^M
    ^M
    #Find the current state and the current alphabet of the turing machine^M
    current_state = turing_machine_dictionary[CURRENT_STATE]^M
    current_alphabet = turing_machine_dictionary[TAPE][int(turing_machine_dictionary[CURRENT_POSITION])]^M
    #For the given current state and alpabet we see the transition in the table^M
    state_transition_table = turing_machine_dictionary[STATE_TRANSITION_TABLE]^M
    #if the state of state+ alphabet do not exist then raise an exception^M
    effective_alphabet = current_alphabet^M
    ^M
    if(state_transition_table.get(current_state) is None):^M
        raise Exception("Current state "+current_state+" not in state transition table")^M
    ^M
    if(state_transition_table[current_state].get(current_alphabet) is None):^M
        if(state_transition_table[current_state].get(turing_machine_dictionary[ANY_SYMBOL_WILD_CARD]) is None):^M
            raise Exception("Current alphabet "+current_alphabet+^M
                            " not in state transition table for state (including any character) "^M
                            +current_state)^M
        else:^M
            effective_alphabet = turing_machine_dictionary[ANY_SYMBOL_WILD_CARD]^M
    ^M
            ^M
    #get the new state, alphabet and shift direction^M
    current_state_transition = state_transition_table[current_state][effective_alphabet]^M
    new_state = current_state_transition[NEW_STATE]^M
    new_alphabet = current_state_transition[NEW_ALPHABET]^M
    shift_direction = current_state_transition[SHIFT]^M
    #set the values in the turing machine dictionary^M
    turing_machine_dictionary[CURRENT_STATE] = new_state^M
    tape = turing_machine_dictionary[TAPE]^M
    current_position = int(turing_machine_dictionary[CURRENT_POSITION])^M
    #String concatination in python^M
    tape =tape[:current_position] +new_alphabet + tape[current_position+1:]^M
    turing_machine_dictionary[TAPE] = tape^M
    shift_direction = current_state_transition[SHIFT]^M
    #set the direction of the head by setting the current position^M
    if(shift_direction == turing_machine_dictionary[RIGHT_SHIFT_SYMBOL]):^M
        turing_machine_dictionary[CURRENT_POSITION] = str(int(turing_machine_dictionary[CURRENT_POSITION]) + 1)^M
    elif(shift_direction == turing_machine_dictionary[LEFT_SHIFT_SYMBOL]):^M
        turing_machine_dictionary[CURRENT_POSITION] = str(int(turing_machine_dictionary[CURRENT_POSITION]) - 1)^M
    elif(shift_direction == turing_machine_dictionary[NO_SHIFT_SYMBOL]):^M
        pass^M
    #If we reach begeining of the tape or the end of the tape then we expand the tape^M
    #This is done by adding the blank symbol at the beginning or end of the tape^M
    #if we are at start of the tape then we add the blank symbol at the beginning^M
    if(int(turing_machine_dictionary[CURRENT_POSITION]) == -1):^M
        tape = turing_machine_dictionary[BLANK_SYMBOL] + tape^M
        turing_machine_dictionary[TAPE] = tape^M
        turing_machine_dictionary[CURRENT_POSITION] = "0"^M
    #if we are at the end of the tape then we add the blank symbol at the end^M
    if(int(turing_machine_dictionary[CURRENT_POSITION]) == len(turing_machine_dictionary[TAPE])):^M
        tape = tape + turing_machine_dictionary[BLANK_SYMBOL]^M
        turing_machine_dictionary[TAPE] = tape^M
^M
^M
def get_turing_machine_state_transition_map(turing_machine_dictionary:dict)->dict:^M
    """^M
    Retrieves the state transition mapping for a Turing machine based on its current state and tape symbol.^M
    The function examines the current state and the symbol under the tape head, then looks up the corresponding^M
    transition in the state transition table. If a direct match is not found, it checks for a wildcard symbol.^M
    If no valid transition exists, an empty dictionary is returned.^M
    ^M
    The purpose of this method is for debugging^M
    Args:^M
        turing_machine_dictionary (dict): ^M
            A dictionary representing the Turing machine, expected to contain the following keys:^M
                - CURRENT_STATE: The current state of the Turing machine.^M
                - TAPE: The tape as a list or string of symbols.^M
                - CURRENT_POSITION: The current position of the tape head (as an integer or string convertible to int).^M
                - STATE_TRANSITION_TABLE: A nested dictionary mapping states and symbols to transitions.^M
                - ANY_SYMBOL_WILD_CARD: The symbol used as a wildcard for transitions.^M
    Returns:^M
        dict: The transition mapping for the current state and symbol, typically containing:^M
            - The next state.^M
            - The symbol to write.^M
            - The direction to move the tape head.^M
        Returns an empty dictionary if no valid transition is found.^M
    """^M
    ^M
    #Find the current state and the current alphabet of the turing machine^M
    current_state = turing_machine_dictionary[CURRENT_STATE]^M
    current_alphabet = turing_machine_dictionary[TAPE][int(turing_machine_dictionary[CURRENT_POSITION])]^M
    #For the given current state and alpabet we see the transition in the table^M
    state_transition_table = turing_machine_dictionary[STATE_TRANSITION_TABLE]^M
    #if the state of state+ alphabet do not exist then raise an exception^M
    effective_alphabet = current_alphabet^M
    ^M
    if(state_transition_table.get(current_state) is None):^M
        return {}^M
    ^M
    if(state_transition_table[current_state].get(current_alphabet) is None):^M
        if(state_transition_table[current_state].get(^M
            turing_machine_dictionary[ANY_SYMBOL_WILD_CARD]) is None):^M
            return {}^M
        else:^M
            effective_alphabet = turing_machine_dictionary[ANY_SYMBOL_WILD_CARD]^M
    ^M
            ^M
    #get the new state, alphabet and shift direction^M
    current_state_transition = state_transition_table[current_state][effective_alphabet]^M
    return current_state_transition^M
^M
def get_turing_machine_print_string(turing_machine_dictionary:dict):^M
    """^M
    Generates a formatted string representation of the current state of a Turing machine.^M
    Args:^M
        turing_machine_dictionary (dict): ^M
            A dictionary containing the Turing machine's current state, tape, and head position.^M
            Expected keys:^M
                - CURRENT_STATE: The current state of the Turing machine (str).^M
                - TAPE: The tape as a string.^M
                - CURRENT_POSITION: The current position of the tape head (int or str convertible to int).^M
                - COLOR_FOR_CURRENT_TAPE_HEAD: ANSI color code for highlighting the tape head (str).^M
                - COLOR_TO_RESET: ANSI color code to reset formatting (str).^M
    Returns:^M
        tuple:^M
            - print_string (str): A string showing the current state and tape, with the tape head highlighted.^M
            - head_position (int): The number of characters before the tape head (used for formatting output).^M
    Comments:^M
        - Highlights the tape head using provided color codes.^M
        - Also provides the position of the tape head in the output string.^M
    """^M
    #Find the current state, tape and position of the head^M
    current_state = turing_machine_dictionary[CURRENT_STATE]^M
    tape = turing_machine_dictionary[TAPE]^M
    position =  int(turing_machine_dictionary[CURRENT_POSITION])^M
    ^M
    #The current position of the head is highlighted in the tape^M
    tape_char = COLOR_FOR_CURRENT_TAPE_HEAD + tape[position]+COLOR_TO_RESET^M
    print_tape = tape[:position]+tape_char+ tape[position+1:]^M
    print_string = current_state+" "+print_tape +" ==> " +str(get_turing_machine_state_transition_map(turing_machine_dictionary))^M
    ^M
    #Also find the location of the head in the tape^M
    head_position = len(current_state) + 1 + position  ^M
    return(print_string,head_position)^M
^M
^M
def print_turing_machine(turing_machine_dictionary):^M
    """^M
    Prints the current state and tape of the Turing machine, highlighting the tape head position.^M
    Args:^M
        turing_machine_dictionary (dict): The dictionary representing the Turing machine.^M
    """^M
    ^M
    execution_counter = turing_machine_dictionary[EXECUTION_COUNTER]^M
    lenth_of_execution_counter = len(str(execution_counter))^M
    print_string,head_position = get_turing_machine_print_string(turing_machine_dictionary)^M
    print(str(execution_counter) + " : " +print_string)^M
    head_position = head_position+ lenth_of_execution_counter + 3  # +3 for the colon and space^M
    print(WHITE_SPACE*head_position+TAPE_HEAD_MARKET)^M
^M
^M
def execute_turing_machine(turing_machine_dictionary:str,delay:float=0.0):^M
    """^M
    Executes a Turing machine simulation using the provided configuration dictionary.^M
    Args:^M
        turing_machine_dictionary (dict): ^M
            A dictionary containing the Turing machine's configuration and state. ^M
            Expected keys include:^M
                - INITIAL_STATE: The starting state of the Turing machine.^M
                - FINAL_STATES: A list or set of halting states.^M
                - INPUT: The initial tape input.^M
                - POSITION: The starting position of the tape head.^M
                - CURRENT_STATE: (will be set) The current state of the machine.^M
                - TAPE: (will be set) The current tape contents.^M
                - CURRENT_POSITION: (will be set) The current position of the tape head.^M
                - STATE_TRANSITION_TABLE: The state transition table.^M
                - ANY_SYMBOL_WILD_CARD: The symbol to represent any character.^M
                - EXECUTION_COUNTER: (will be set) The execution counter.^M
        delay(float):^M
            Optional delay in seconds between each step of the Turing machine execution.^M
    Side Effects:^M
        - Updates the turing_machine_dictionary with the current state, tape, and position.^M
        - Prints the Turing machine's state at each step.^M
    Behavior:^M
        - Initializes the Turing machine's state, tape, and position.^M
        - Iteratively executes transitions until a halting state is reached.^M
        - Prints the Turing machine's state before and after execution.^M
    """^M
    # Initialize the current state from the initial state^M
    # Set up the tape and position from the input and starting position^M
    # Loop until a halting state is reached^M
    # Print the Turing machine's state at each step^M
    # Execute the transition to the next state^M
    # Break the loop if the current state is a halting state^M
    # Print the final state of the Turing machine^M
    ^M
    #Before we start executing we initialise the Turning machine^M
    # We set current state of tape, position and current state^M
    # to the inputs we have received^M
    intial_state = turing_machine_dictionary[INITIAL_STATE]^M
    halt_states = turing_machine_dictionary[FINAL_STATES]^M
    current_state = intial_state^M
    turing_machine_dictionary[CURRENT_STATE] = current_state^M
    input = turing_machine_dictionary[INPUT]^M
    tape = input^M
    turing_machine_dictionary[TAPE] = tape^M
    position = turing_machine_dictionary[POSITION]^M
    current_position = position^M
    turing_machine_dictionary[CURRENT_POSITION] = current_position^M
    turing_machine_dictionary[EXECUTION_COUNTER] = EXECUTION_COUNTER_INITIAL_VALUE^M
    while(True):^M
        #Print the current state of the Turing machine^M
        print_turing_machine(turing_machine_dictionary)^M
        #execute the next state transition^M
        execute_to_next_state(turing_machine_dictionary)^M
        #increment the execution counter^M
        #This is used to track the number of transitions executed^M
        incremented_execution_counter = int(turing_machine_dictionary[EXECUTION_COUNTER])+ EXECUTION_COUNTER_INCREMENT^M
        turing_machine_dictionary[EXECUTION_COUNTER] = str(incremented_execution_counter)^M
        ^M
        if(delay>  0):^M
            time.sleep(delay)^M
        #Is the machine in halted state? If so break^M
        if(is_given_state_in_states(halt_states,turing_machine_dictionary[CURRENT_STATE]) == True):^M
            break^M
    #Print final state of the Turing machine before termination^M
    print_turing_machine(turing_machine_dictionary)^M
    if(delay>  0):^M
        time.sleep(delay)^M
    print("Turning Machine : "+turing_machine_dictionary[TURING_MACHINE_NAME_KEY])^M
    if(delay>  0):^M
        time.sleep(delay)^M
    print("Turning Machine Description : "+turing_machine_dictionary[TURING_MACHINE_DESCRIPTION])^M
    if(delay>  0):^M
        time.sleep(delay)^M
    print("Turing Machine has halted in state: "+ turing_machine_dictionary[CURRENT_STATE])^M
    if(delay>  0):^M
        time.sleep(delay)^M
    print("Number of execution cycles (Time Complexcity) : "+ str(turing_machine_dictionary[EXECUTION_COUNTER]))^M
    if(delay>  0):^M
        time.sleep(delay)    ^M
    print("Tape Used (Space Complexcity) : "+ str(len(turing_machine_dictionary[TAPE])))^M
    if(delay>  0):^M
        time.sleep(delay)    ^M
    print("Initial Input    :   "+ turing_machine_dictionary[INPUT])^M
    if(delay>  0):^M
        time.sleep(delay)    ^M
    print("Final Output     :   "+ turing_machine_dictionary[TAPE])^M
^M
def main(turing_machine_file:str=None, delay:float=0):^M
    """^M
    Executes a Turing machine simulation based on the provided configuration file.^M
    Args:^M
        turing_machine_file (str, optional): Path to the Turing machine configuration file. Defaults to None.^M
        delay (float, optional): Delay in seconds between each step of the simulation. Defaults to 0.^M
    Raises:^M
        ValueError: If the Turing machine configuration is invalid.^M
    Side Effects:^M
        - Prints the contents of the configuration file.^M
        - Prints the parsed Turing machine dictionary in JSON format.^M
        - Executes the Turing machine simulation with optional delay.^M
    """^M
    #Read the Turing machine file into a list of lines^M
    file_lines = read_file_into_list(turing_machine_file)^M
    #Print the file lines for debugging^M
    print_file(file_lines)^M
    #Remove comments and empty lines from the list of lines^M
    file_lines = remove_comments_and_empty_lines_from_list(file_lines)^M
    #Convert this list into a dictionary which represents the Turing machine^M
    turing_machine_dictionary = convert_list_into_dictionary(file_lines)^M
    #Validate the Turing machine dictionary^M
    validate_turing_machine(turing_machine_dictionary)^M
    #Print the Turing machine dictionary in JSON format for debugging and checking if file was^M
    #Correctly parsed^M
    print(json.dumps(turing_machine_dictionary,indent=4))^M
    #Execute the Turing machine simulation^M
    execute_turing_machine(turing_machine_dictionary,delay)^M
    ^M
^M
if __name__ == "__main__":^M
    ^M
    # Entry point for the script^M
    # This block checks if the script is being run directly (not imported as a module)^M
    if len(sys.argv) > 1:^M
        #If the script is run with arguments, it expects the file name to be the first argument^M
        #The second argument is optional and represents the delay in seconds between each step of the simulation^M
        file_name = sys.argv[1]^M
        delay = 0.0^M
        if(len(sys.argv) == 3):^M
            delay = float(sys.argv[2])^M
        #Run the Turing machine simulation with the provided file name and optional delay^M
        main(file_name,delay)    ^M
    else:^M
        #If the script is run without arguments, it prints a message to the console^M
        print("Please Pass file Name and optional delay in seconds between each step of the simulation")^M
        